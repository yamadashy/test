<!doctype html><html lang="ja"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="企業のテックブログの更新をまとめたRSSフィードを配信しています。記事を読んでその企業の技術・カルチャーを知れることや、質の高い技術情報を得られることを目的としています。"><meta name="author" content="yamadashy"><meta name="robots" content="index, follow"><meta property="og:url" content="https://yamadashy.github.io/tech-blog-rss-feed/"><meta property="og:title" content="ククログのフィード｜企業テックブログRSS"><meta property="og:image" content="https://yamadashy.github.io/tech-blog-rss-feed/images/og-image.png"><meta property="og:description" content="企業のテックブログの更新をまとめたRSSフィードを配信しています。記事を読んでその企業の技術・カルチャーを知れることや、質の高い技術情報を得られることを目的としています。"><meta property="og:type" content="website"><meta property="og:site_name" content="企業テックブログRSS"><meta property="og:locale" content="ja_JP"><meta name="twitter:card" content="summary"><meta property="twitter:domain" content="https://yamadashy.github.io/tech-blog-rss-feed/"><meta 
property="twitter:url" content="https://yamadashy.github.io/tech-blog-rss-feed/"><meta name="twitter:title" content="ククログのフィード｜企業テックブログRSS"><meta name="twitter:description" content="企業のテックブログの更新をまとめたRSSフィードを配信しています。記事を読んでその企業の技術・カルチャーを知れることや、質の高い技術情報を得られることを目的としています。"><meta name="twitter:image" content="https://yamadashy.github.io/tech-blog-rss-feed/images/og-image.png"><meta name="thumbnail" content="https://yamadashy.github.io/tech-blog-rss-feed/images/og-image.png"><link rel="preload" href="../../styles/bundle.css" as="style"><meta name="google-site-verification" content="GPLvXv8kYtLMW912ZS54DKFEZL6ruOrjOFLdHVTo37o"><link rel="shortcut icon" href="../../images/favicon.ico"><link rel="apple-touch-icon" href="../../images/apple-icon.png"><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="../../feeds/atom.xml"><link rel="alternate" type="application/rss+xml" title="RSS2.0" href="../../feeds/rss.xml"><link rel="alternate" type="application/json" 
href="../../feeds/feed.json"><link rel="stylesheet" type="text/css" href="../../styles/bundle.css"><script async src="https://www.googletagmanager.com/gtag/js?id=G-CNNNTL0NB3"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-CNNNTL0NB3")</script><title>ククログのフィード｜企業テックブログRSS</title></head><body><header role="banner" class="ui-section-header"><div class="ui-layout-container"><div class="ui-section-header__layout ui-layout-flex"><a href="https://yamadashy.github.io/tech-blog-rss-feed/" role="link" aria-label="#"><img src="../../images/icon.png" alt="サイトロゴ" loading="eager" width="96" height="96"> <span class="ui-section-header__title">企業テックブログRSS</span></a><div class="ui-section-header__links"><a href="https://github.com/yamadashy/tech-blog-rss-feed/" role="link" aria-label="#" target="_blank"><img src="../../images/icon-github.png" alt="GitHubロゴ" loading="eager" width="96" height="96"> </a><a 
href="https://x.com/yamadashy" role="link" aria-label="#" target="_blank"><img src="../../images/icon-x.png" alt="Xロゴ" loading="eager" width="96" height="96"></a></div></div></div></header><main role="main"><nav class="ui-nav"><div class="ui-layout-container"><div class="ui-section-nav__layout ui-layout-flex"><a class="ui-section-nav__link" href="../../">フィード</a> <a class="ui-section-nav__link" href="../../hot/">人気フィード</a> <a class="ui-section-nav__link" href="../../blogs/">ブログ一覧</a></div></div></nav><section class="ui-section-content ui-section-feed"><div class="ui-layout-container"><h2 class="ui-typography-heading">ククログ</h2><div class="ui-container-blog-summary"><div class="ui-blog-summary"><a class="ui-blog-summary__link" href="https://www.clear-code.com/blog/">https://www.clear-code.com/blog/</a><p class="ui-blog-summary__description">ククログはクリアコードのブログです。開発に関わる技術情報や、会社での出来事を記録しています。</p></div></div><h3 class="ui-typography-heading">フィード</h3><div 
class="ui-section-content--feature ui-layout-grid ui-layout-grid-3 ui-container-feed ui-container-feed--no-image"><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://www.clear-code.com/blog/2025/1/17/goodbye-fat-gem-2025.html"><picture><source type="image/avif" srcset="../../images/feed-thumbnails/UJNwLPEZlk-256.avif 256w, ../../images/feed-thumbnails/UJNwLPEZlk-512.avif 512w" sizes="(min-width: 75rem) 16rem, (min-width: 64rem) 19rem, (min-width: 48rem) 19rem, 8rem"><img alt="記事のアイキャッチ画像" loading="lazy" src="../../images/feed-thumbnails/UJNwLPEZlk-256.jpeg" width="512" height="473" srcset="../../images/feed-thumbnails/UJNwLPEZlk-256.jpeg 256w, ../../images/feed-thumbnails/UJNwLPEZlk-512.jpeg 512w" sizes="(min-width: 75rem) 16rem, (min-width: 64rem) 19rem, (min-width: 48rem) 19rem, 8rem"></picture></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://www.clear-code.com/blog/2025/1/17/goodbye-fat-gem-2025.html">2025年、fat gemをやめる</a><div
 class="ui-feed-item__hatena-count" title="はてなブックマーク数"><img src="../../images/hatenabookmark-icon.png" alt="はてなブックマークアイコン" loading="lazy" width="96" height="96"> <span>21</span></div><div class="ui-feed-item__blog-title">ククログ</div><div class="ui-feed-item__summary">
fat gemを簡単に作れるようにするgemであるrake-compilerをメンテナンスしている須藤です。2019年にもfat gemをやめる話をしていましたが、5-6年経ってもまだfat gemが使われているので、この5-6年でのアップデートを紹介します。おさらいまず、簡単に関連情報を整理しておきます。まず、「fat gem」についてです。fat gemとはビルド済みバイナリーが入ったgemのことです。pre-compiled gemとかnative gemとかbinary gemとかと呼ばれることもあります。fat gemの嬉しいところは次の通りです。インストール時にビルドツールが必要ない（そもそもビルドしないから）インストール時にビルドで失敗しない（そもそもビルドしないから）インストールが速い（ビルドしないから）fat gemのキビシイところは次の通りです。開発者視点：たくさんの環境ごとにfat gemを用意してリリースする必要がある（たとえば、このあたりを便利にしてくれるrake-compiler-dockは13個の環境をサポートしている）クロスコンパイルをしないといけないが、クロスコンパイルは普通にコンパイルするより大変（多くのプロダクトはクロスコンパイルサポートをがんばっていない）新しいCRubyがリリースされたらできるだけ早く新しいCRuby用のfat gemをリリースする必要がある依存ライブラリーに脆弱性が発見されたら迅速に対応してリリースしないといけないリリース作業が大変ユーザー視点：新しいCRubyで使えるようになるまでにラグがある依存ライブラリーが脆弱性に対応してもfat gemが対応してくれないと対応できない複数のfat gemが同じ依存ライブラリーの違うバージョンを使っているとコンフリクトすることがある同じことをもう少し説明しているものは↓にあるので、省略されすぎてピンとこないという場合は↓も読んでみてください。2019年、fat gemをやめるRubyKaigi Tkaeout 2020 - Goodbye fat gem #rubykaigiところで、2024年にどのくらいのgemがfat gemとしてリリースされたか調べたいんですが、どうやって調べればいいか知っている人いません？RubyGems.org APIだとできない気がするん
</div><div class="ui-feed-item__date" title="2025-01-16 15:00:00">5日前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://www.clear-code.com/blog/2025/1/16/work-around-network-issue-with-almalinux-on-github-actions.html"><picture><source type="image/avif" srcset="../../images/feed-thumbnails/UJNwLPEZlk-256.avif 256w, ../../images/feed-thumbnails/UJNwLPEZlk-512.avif 512w" sizes="(min-width: 75rem) 16rem, (min-width: 64rem) 19rem, (min-width: 48rem) 19rem, 8rem"><img alt="記事のアイキャッチ画像" loading="lazy" src="../../images/feed-thumbnails/UJNwLPEZlk-256.jpeg" width="512" height="473" srcset="../../images/feed-thumbnails/UJNwLPEZlk-256.jpeg 256w, ../../images/feed-thumbnails/UJNwLPEZlk-512.jpeg 512w" sizes="(min-width: 75rem) 16rem, (min-width: 64rem) 19rem, (min-width: 48rem) 19rem, 8rem"></picture></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://www.clear-code.com/blog/2025/1/16/work-around-network-issue-with-almalinux-on-github-actions.html">GitHub Actions上のUbuntuでAlmaLinuxの仮想マシンを動かすときの注意点</a><div class="ui-feed-item__hatena-count" title="はてなブックマーク数"><img src="../../images/hatenabookmark-icon.png" alt="はてなブックマークアイコン" loading="lazy" width="96" height="96"> <span>2</span></div><div class="ui-feed-item__blog-title">ククログ</div><div class="ui-feed-item__summary">
Mroongaのメンテナンスもしている堀本です。今回はGitHub Actions上でAlmaLinuxの仮想マシンを作って何かする人向けの記事です。Groongaとその関連プロダクト（PGroongaやMroongaなど）は、様々なOS向けにパッケージを提供しています。提供するパッケージはGitHub Actions上でビルドしたり、テストしたりしています。今回は、AlmaLinux向けのパッケージのテストをする環境を作る時に躓いた点があったので、その回避策を紹介しようと思います。最初にどんな問題が発生したかを紹介し、次にどのように解決したかを紹介します。では、まずどんな問題が発生したかを紹介します。MroongaのCIでは、Ubuntu上にIncusをインストールし、それを使って仮想マシンを立ち上げることでAlmaLinuxの環境を用意していますが、この仮想マシンを起動するときに問題が発生しました。仮想マシンから外部のネットワークに接続できないMroongaのCIでは、AlmaLinuxの仮想マシンを起動後にdnf updateを実施しますが、このコマンドが失敗しGitHub Actionsの実行が中断されてしまいました。具体的には以下のエラーが発生していました。Errors during downloading metadata for repository &#39;baseos&#39;: - Curl error (6): Couldn&#39;t resolve host name for https://mirrors.almalinux.org/mirrorlist/8/baseos [Could not resolve host: mirrors.almalinux.org] - Curl error (6): Couldn&#39;t resolve host name for https://mirrors.almalinux.org/mirrorlist/8/baseos?countme=1 [Could not resolve host: mirrors.almalinux.org]Error: Failed to download metadata for repo &#39;baseos&#39;: Cannot prepare internal mirrorlist: Curl
</div><div class="ui-feed-item__date" title="2025-01-15 15:00:00">6日前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://www.clear-code.com/blog/2025/1/16/how-to-aggregate-issues-for-github-projects.html"><picture><source type="image/avif" srcset="../../images/feed-thumbnails/UJNwLPEZlk-256.avif 256w, ../../images/feed-thumbnails/UJNwLPEZlk-512.avif 512w" sizes="(min-width: 75rem) 16rem, (min-width: 64rem) 19rem, (min-width: 48rem) 19rem, 8rem"><img alt="記事のアイキャッチ画像" loading="lazy" src="../../images/feed-thumbnails/UJNwLPEZlk-256.jpeg" width="512" height="473" srcset="../../images/feed-thumbnails/UJNwLPEZlk-256.jpeg 256w, ../../images/feed-thumbnails/UJNwLPEZlk-512.jpeg 512w" sizes="(min-width: 75rem) 16rem, (min-width: 64rem) 19rem, (min-width: 48rem) 19rem, 8rem"></picture></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://www.clear-code.com/blog/2025/1/16/how-to-aggregate-issues-for-github-projects.html">
GitHub ProjectsにOrganizationを横断してIssueを集約し、トラッキングしやすくする方法</a><div class="ui-feed-item__hatena-count" title="はてなブックマーク数"><img src="../../images/hatenabookmark-icon.png" alt="はてなブックマークアイコン" loading="lazy" width="96" height="96"> <span>2</span></div><div class="ui-feed-item__blog-title">ククログ</div><div class="ui-feed-item__summary">
GitHubを利用して様々なプロジェクトに関わっている場合、関連するissueを一覧で確認できると便利な場合があります。Notificationsのフィルタを活用すればある程度一覧性を担保できますが、その結果を複数人で共有、加工等したい場合には不向きです。GitHub ProjectsではOrganization配下に作成されたリポジトリのissueを任意で追加できるので、トリアージが必要なissueを登録しておくと一覧できて有用です。クリアコードではFluentdの開発にも深く関わっていることから、Fluentdのサポートサービスを提供しています。Fluentdにはプラグインのエコシステムがありますが、関連するリポジトリはあちこちに分散しています。それらのリポジトリで新規に起票されたissueをGitHub Projectsで一覧できると有用なのですが、そのようなしくみは整えられていませんでした。そこで、GitHub ProjectsにOrganizationを横断して既存のissueを集約し、Fluentd Kanbanとしてトラッキングしやすくした方法について紹介します。GitHub Projectsへの既存issueの登録方法はいくつかあります。ProjectsのAdd itemからissueのURLを登録するProjectsの組み込みのワークフローを作成して登録を自動化する既存のGitHub Actionを利用してissueの登録を自動化する独自にissueの登録を自動化する以下それぞれ説明します。GitHub ProjectsのAdd itemからissueのURLを登録するGitHub Projectsにissueを集約するための、もっともシンプルなやりかたです。project への項目の追加 - issue または pull request の URL の貼り付け に記載されているように、URLを貼り付けてEnterキーを押すことで異なるOrganizationのissueなども追加可能です。ただし、毎回手作業なので随時発生するissueに追従していくのは非常に手間がかかります。監視対象のリポジトリがとても少ないか、issueの登録頻度が少ない場合に向いています。当然ながら、監視対象のリポジトリの活動が活発になるにつれて破綻するやりかたです。GitH
</div><div class="ui-feed-item__date" title="2025-01-15 15:00:00">6日前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://www.clear-code.com/blog/2025/1/15/fluent-plugin-filter-split.html"><picture><source type="image/avif" srcset="../../images/feed-thumbnails/UJNwLPEZlk-256.avif 256w, ../../images/feed-thumbnails/UJNwLPEZlk-512.avif 512w" sizes="(min-width: 75rem) 16rem, (min-width: 64rem) 19rem, (min-width: 48rem) 19rem, 8rem"><img alt="記事のアイキャッチ画像" loading="lazy" src="../../images/feed-thumbnails/UJNwLPEZlk-256.jpeg" width="512" height="473" srcset="../../images/feed-thumbnails/UJNwLPEZlk-256.jpeg 256w, ../../images/feed-thumbnails/UJNwLPEZlk-512.jpeg 512w" sizes="(min-width: 75rem) 16rem, (min-width: 64rem) 19rem, (min-width: 48rem) 19rem, 8rem"></picture></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://www.clear-code.com/blog/2025/1/15/fluent-plugin-filter-split.html">Fluentdでレコードを分割するプラグインの紹介</a><div 
class="ui-feed-item__blog-title">ククログ</div><div class="ui-feed-item__summary">
クロスプラットフォームで動作し、オープンソースであるデータ収集ソフトウェアとしてFluentdがあります。Fluentdはさまざまな用途にあわせてプラグインにより機能を拡張できます。多くのプラグインが開発されているのは、要件を満たすべく新規にプラグインが開発される事例があるためです。Fluentdで収集したログは、Fluentd内部ではイベントという形で処理されます。イベントはタグと日時、レコードから構成され、収集されたデータはレコードに詰め込まれます。発生したログをアーカイブ目的のため手を加えずになんらかの外部サービスに保存するだけということもありますが、レコードに詰め込まれたデータの加工が必要となる場合が多々あります。Fluentdでは非常に多くのプラグインが開発されてきているので、レコードを分割するという目的だけでも専用のものがいくつかあります。今回はそのようなプラグインの中から、Fluentdサポートの一環として、お客様の要望に応じて新規でプラグインを開発した事例を紹介します。新規プラグインの開発のきっかけすでに言及したように、クリアコードではFluentdサポートを提供しています。このサービスでは技術サポートとして、エラー時のソースコードレベルの解析のみならず、お客様の要望に応じて既存のプラグインの修正や、場合によっては新規に開発を行うこともあります。ご相談いただいた事例では、フィルタやラベルの設定を駆使し、record_modifierでレコードを加工するやりかたを検討されていたようです。しかし、それによってFluentdの設定が複雑化し、メンテナンスの継続性に難があったことからその方法は不採用となり、お困りのため弊社に相談がありました。実現したかった加工の例要望頂いていたのは、次のような入力があった場合に、レコードを分割するフィルタ処理を実現することでした。入力例:{&quot;key1&quot;:&quot;value1&quot;, &quot;key2&quot;:&quot;value2&quot;, &quot;message&quot;:[ &quot;v1&quot;, &quot;v2&quot;, &quot;v3&quot;] }期待する加工後の出力:{&quot;key1&quot;:&quot;value1&quot;, &quot;key2&quot;:&quot;value2&quot;, &quot;message&quot;: &quot;v1&quot;}{&quot;key1&quot;:&quot;value1&quot;, &quot;key2&quot;:&quot;value2&quot;, &quot;message&quot;: &quot;v2&quot;}{&quot;key1&quot;:&quot;value1&quot;,
</div><div class="ui-feed-item__date" title="2025-01-14 15:00:00">7日前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://www.clear-code.com/blog/2025/1/7/ruby-memory-view-optimized-sum.html"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://www.clear-code.com/blog/2025/1/7/ruby-memory-view-optimized-sum.html">RubyのMemoryViewでsumを高速化</a><div class="ui-feed-item__blog-title">ククログ</div><div class="ui-feed-item__summary">
RubyとApache Arrowの開発に参加している須藤です。RubyのMemoryViewの使い方がわからないという話を聞いてsumをするサンプルを作ったので紹介します。MemoryViewRubyのMemoryViewは、ざっくり言うと、同じ型の値が連続して並んでいるデータをゼロコピーで交換するための仕組みです。まじめな説明はMemoryView: Ruby 3.0 から導入される数値配列のライブラリ間共有のための仕組みなどを参照してください。MemoryViewを使うと、異なるライブラリー間で効率よくデータを交換したり、データを高速に処理したりできます。今回はデータを高速に処理する方の使い方を紹介します。Rubyはすべてがオブジェクトなので1もオブジェクトです。CRubyは1はCの1としては表現していません。そのため、1 + 2は「Rubyの1をCの1に変換したもの」と「Rubyの2をCの2に変換したもの」をCの+で足し算しています。そして、足した結果であるCの3をRubyの3に変換します。MemoryViewで扱うデータは1をCの1として表現しています。そのため、RubyとCの変換をすることなく1 + 2を計算できます。このやり方を紹介します。MemoryViewでsumMemoryViewはCのAPIなので拡張ライブラリー内でMemoryViewを使うことになります。今回は[1, 2, 3]のような数値の配列データのsumを求める処理を実装します。[1, 2, 3].sumと同じ挙動をするものです。まず、必要なヘッダーファイルをincludeします。#include &lt;ruby.h&gt;#include &lt;ruby/memory_view.h&gt;拡張ライブラリーの初期化関数を作ります。今回はMemoryViewSample.#sumを作ります。voidInit_memory_view_sample(void){ VALUE rb_mMemoryViewSample = rb_define_module(&quot;MemoryViewSample&quot;); rb_define_module_function(rb_mMemoryViewSample, &quot;sum&quot;, mvs_sum, 1);}それでは、本体のmvs_sum()を実装します。まず、rb_memory_view_
</div><div class="ui-feed-item__date" title="2025-01-06 15:00:00">15日前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://www.clear-code.com/blog/2024/12/27/fluentd-how-to-make-plugin-support-zero-downtime-restart.html"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://www.clear-code.com/blog/2024/12/27/fluentd-how-to-make-plugin-support-zero-downtime-restart.html">Fluentd: Inputプラグインをゼロダウンタイム・リスタート機能に対応させる方法</a><div class="ui-feed-item__blog-title">ククログ</div><div class="ui-feed-item__summary">
こんにちは。Fluentdのメンテナーの福田です。2024年12月14日にリリースした Fluent Package v5.2.0 では、ゼロダウンタイム・リスタートおよびアップデートの機能を追加しました。この機能では、in_udp, in_tcp, in_syslog, の3種のInputプラグインの動作を止めずに、リスタートやアップデートを行うことができます。本記事では、Fluentdのプラグイン開発者向けに、その他のInputプラグインをこの機能に対応させる方法について紹介します。前置き: Fluent Package v5.2.0 のゼロダウンタイム・リスタート/アップデート機能2024年12月14日にリリースした Fluent Package v5.2.0 では、ゼロダウンタイム・リスタートおよびアップデートの機能を追加しました。詳しくは、次の記事をご覧ください。Fluent Package v5.2.0 リリース - ゼロダウンタイム・アップデートInputプラグインをゼロダウンタイム・リスタート機能に対応させる方法Inputプラグインをゼロダウンタイム・リスタート機能に対応させる方法は、マルチワーカーに対応させる方法と基本的に同様です。そのInputプラグインをマルチワーカーに対応させる場合は、それがマルチワーカーで動作して問題ないことを確認した上で、次のようにmulti_workers_ready?をオーバーライドして、trueを返すようにします。def multi_workers_ready? trueend同様にゼロダウンタイム・リスタートに対応させる場合は、ゼロダウンタイム・リスタートで動作して問題ないことを確認（後述）した上で、次のようにzero_downtime_restart_ready?をオーバーライドして、trueを返すようにします。def zero_downtime_restart_ready? trueend例: https://github.com/fluent/fluentd/blob/d7164ddc73f006de345acec8d9beb1846fb6bcb3/lib/fluent/plugin/in_udp.rb#L73-L75ゼロダウンタイム・リスタートで動作可能である条件は次の通りです。他のFluentdインスタン
</div><div class="ui-feed-item__date" title="2024-12-26 15:00:00">1ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://www.clear-code.com/blog/2024/12/27/fluent-package-v5.2.0.html"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://www.clear-code.com/blog/2024/12/27/fluent-package-v5.2.0.html">Fluent Package v5.2.0 リリース - ゼロダウンタイム・アップデート</a><div class="ui-feed-item__blog-title">ククログ</div><div class="ui-feed-item__summary">
こんにちは。Fluentdのメンテナーの福田です。2024年12月14日に Fluent Package v5.2.0 をリリースしました。本リリースでは、ゼロダウンタイム・アップデート機能を追加しました。これによって、今後のバージョンではリスタートやアップデートをゼロダウンタイムで実行できるようになります。この記事では、メンテナーの観点から Fluentd の最新パッケージの動向を詳しく解説します。前置き: td-agent のEOLと Fluent PackageFluent Package とは、コミュニティーが提供している Fluentd のパッケージです。それまでコミュニティーが提供していた Fluentd のパッケージとして td-agent がありましたが、td-agent は2023年12月31日限りでサポート終了となりました。Drop schedule announcement about EOL of Treasure Agent (td-agent) 4Fluent Package は td-agent v4 の後継パッケージであり、ある程度の互換性を保っています。多くのケースでは td-agent v4 から簡単にアップデート可能です。また、今回リリースした v5.2.0 は通常版となりますが、並行してLTS版も提供しています。新機能をすぐに使う必要がない、長期に渡って安定して使いたい、という場合はLTS版がおすすめです。現在 td-agent をお使いの方は、ぜひ Fluent Package へのアップデートをご検討ください。詳しくは、次の資料をご覧ください。公式ブログ(英語): Upgrade to fluent-package v5弊社提供資料: Fluent Package LTS（長期サポート版Fluentdパッケージ）ガイド 弊社ブログ: Fluent Package v5.0.2リリース - in_tailプラグインの重大な不具合の修正（前半で Fluent Package についての基本的な情報を紹介しています）Fluent Package v5.2.02024年12月14日に最新の通常版として Fluent Package v5.2.0 をリリースしました。（現時点でのLTS版の最新は v5.0.5 となっています）本バー
</div><div class="ui-feed-item__date" title="2024-12-26 15:00:00">1ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://www.clear-code.com/blog/2024/12/26/my-misunderstanding-about-git-push.html"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://www.clear-code.com/blog/2024/12/26/my-misunderstanding-about-git-push.html">git push origin mainの意味をずっと勘違いしていた話</a><div class="ui-feed-item__blog-title">ククログ</div><div class="ui-feed-item__summary">
こんにちは。Gitはコマンド操作とクライアントアプリ操作を使い分けるのが好きな福田です。突然ですが問題です。このGitのよくあるコマンドラインを見てください。git push origin mainこのmainって、どのmainだと思いますか？...答えは、ローカルリポジトリーのmainです。え、当たり前ですかね...？なんと私は10年以上にわたって、これがoriginのmainのことだと勘違いしながら使い続けてきました。え、結果的に同じことじゃん、って？まあそうなんですが、この勘違いが見事にpush誤爆を生みまして、真相を知った私はまあ大きな衝撃を受けたわけです。この記事では、私の勘違いポイントと、その勘違いが招いたpush誤爆を紹介します。私の勘違いポイントgit push remote branch-AというGitコマンドを考えてみます。私はこのコマンドが、ローカルリポジトリーの今のブランチを、remoteのbranch-Aにpushするというものだと勘違いしたまま、10年以上使っていました。正しくは、ローカルリポジトリーのbranch-Aを、remoteのbranch-Aにpushするです。このコマンドで指定するbranch-Aは、push元のブランチ名を指します。私はこれをpush先だと勘違いしていたわけです。いつも「元」と「先」が同じブランチ名だったので、ずっと気付かなかったわけですね。。さて、push先のブランチ名はどのように決まるのでしょうか？実は冒頭のコマンドは省略形であり、自動的にpush元と同じになります（大抵は1）。そして、省略しない場合は次のような形になります。git push remote branch-A:branch-Bこれがフルの形で、ローカルリポジトリーのbranch-Aを、remoteのbranch-Bにpushするということになります。この最後の:branch-Bの部分が省略可能なわけです。冒頭のコマンドは、次の省略形だったわけです。git push remote branch-A:branch-A勘違いが招いたpush誤爆その時私は、GitHubのとあるリポジトリーに寄せられた、とあるpull requestのレビューをしていました。最後に少し修正が必要になったので、私が代わりに修正をpushしようと思ったのが発端です。こう
</div><div class="ui-feed-item__date" title="2024-12-25 15:00:00">1ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://www.clear-code.com/blog/2024/12/26/how-to-control-needrestart-behavior.html"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://www.clear-code.com/blog/2024/12/26/how-to-control-needrestart-behavior.html">debパッケージからneedrestartの挙動を抑制する方法</a><div class="ui-feed-item__blog-title">ククログ</div><div class="ui-feed-item__summary">
先日 fluent-package v5.2.0をリリースしました。v5.2.0の注目に値する機能として、対応しているバージョンのパッケージ間でダウンタイムなしのアップグレードが実現できるという点があります。（つまり、v5.2.0にアップグレードした後、その次のバージョンに改めて更新するときにダウンタイムなしでパッケージを更新できるということです。）この機能を実現するためには、パッケージ更新時のサービスの挙動を制御し、意図しないタイミングで勝手にサービスがリスタートされないようにする必要がありました。本記事では、サービスのリスタートに関連するneedrestartの機能をパッケージ側から抑制する方法について説明します。debパッケージにおけるneedrestartの影響についてneedrestartとは、パッケージの更新時に再起動が必要なサービスを通知してくれるしくみです。apt upgradeなどでパッケージを更新しているときに、最後にどのサービスを再起動するかどうか対話的に確認が求められることがありますが、その機能はneedrestartによって実現されています。1詳細は 第718回needrestartで学ぶパッケージのフック処理によくまとめられているので、そちらを参照するとよいでしょう。fluent-packageでは、ダウンタイムなしのアップグレードを実現するため、サービスの再起動のタイミングを自前で制御しています。そのため、意図しないタイミングでサービスの再起動が実行されうるneedrestartのしくみとは相性が悪いです。ゆえに、fluent-packageの提供するfluentdサービスをneedrestartのチェック対象からはずすようにしています。具体的には、次のようなファイルを/etc/needrestart/conf.d/50-fluent-package.confとして配置しています。2# Configuration for needrestart# Always suppress restarting by needrestart.$nrconf{blacklist_rc} = [ qr(^fluentd&#92;.service$)];このようにすることで、意図しないタイミングでのfluentdサービスの再起動を抑制できます。抑制できている場合
</div><div class="ui-feed-item__date" title="2024-12-25 15:00:00">1ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://www.clear-code.com/blog/2024/12/26/firefox-release-schedule.html"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://www.clear-code.com/blog/2024/12/26/firefox-release-schedule.html">Firefoxのサポート期限の調べ方</a><div class="ui-feed-item__blog-title">ククログ</div><div class="ui-feed-item__summary">
Firefox・Thunderbirdの法人向けサポートサービスをご提供している関係で、「Firefoxのバージョン何々のサポート期限はいつまでなのか？」という趣旨のお問い合わせを頂くことがあります。様々な意味に取れる「サポート期限」という言葉ですが、ここでは「Firefoxの特定のメジャーバージョンについて、セキュリティアップデート（マイナーアップデート）が提供される期間」を指します。このサポート期限は、公式には明確な日付で記載されることがなく、具体的な日付を知るにはいくつかの情報を元に演繹する必要があります。この記事では、オフィシャルに示されている情報からFirefoxのサポート期限を読み取る手順をご紹介します。Firefoxのサポート期限の考え方本稿執筆時点で、Firefoxのサポート期間を示す公式の情報は、Firefox の更新チャンネルの選択 | 法人向け Firefox ヘルプというページに記載されています。このページでは「更新はこれだけの期間提供される」という表現になっていて、「サポート期限はいつまでである」という表現にはなっていないのですが、演繹的に以下のような意味となります。通常リリース版は4週ごとのメジャーアップデートと、その間のマイナーアップデートがある→4週が経過したらそのメジャーバージョンのサポート期限は終了し、それ以後マイナーアップデートは提供されない（次のメジャーバージョンに更新する必要がある）ESRは約52週（1年）ごとのメジャーアップデートと、その間の最低4週ごとのマイナーアップデートがある→約52週（1年）が経過したらそのメジャーバージョンのサポート期限は終了し、それ以後マイナーアップデートは提供されない（次のメジャーバージョンに更新する必要がある）Firefoxのサポート期限の情報ソースと、情報の読み取り方ここから各バージョンの具体的なサポート期限を把握するためには、将来のリリース予定が記されているFirefox Release Calendarを参照する必要があります。こちらのカレンダーで特に重要なのが、Version列、Matching ESR列、Release day列の3つです。カレンダーはQuarter列で四半期ごとにグループ化されていますが、2025年の第2～第3四半期（Q2～Q3）部分を抜き出すと、以下のようになっ
</div><div class="ui-feed-item__date" title="2024-12-25 15:00:00">1ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://www.clear-code.com/blog/2024/12/25/addr2line-and-separated-debug-information.html"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://www.clear-code.com/blog/2024/12/25/addr2line-and-separated-debug-information.html">デバッグ情報が分離されていてもaddr2lineでソースコードの位置を特定する方法</a><div class="ui-feed-item__blog-title">ククログ</div><div class="ui-feed-item__summary">
Rubyが好きなのにRubyよりCやC++を書いている時間の方が長い須藤です。Cで書かれたプログラムのデバッグに便利なaddr2lineをデバッグ情報が分離されたファイルに対して使う方法を説明します。addr2line&quot;&gt;addr2lineまず、前提知識としてaddr2lineについて説明します。あれ？説明するか、と思ってみたもののあんまり詳しく知らない気がするな。。。まぁ、私が知っている範囲で説明します。addr2lineはGNU Binutilsに含まれているプログラムの1つで、アドレスを元に、それに対応するソースコードの位置を特定する便利プログラムです。といっても、これでピンとくる人はいないでしょう。どの「アドレス」を元にするの？というところがピンとこないと思います。多くの場合、addr2lineに与えるアドレスはglibcのバックトレース用関数で出力したバックトレース内に含まれています。というか、私がaddr2lineを使うときはこのバックトレースで取得できたアドレスしか使っていません。他の人がどうやって使っているのか知りませんが、これが代表的な使い方じゃないかな。たとえば、glibcのバックトレース用関数を使うと次のような情報を得られます。これはGroongaが実際に出力したログから抜粋したものです。/lib/x86_64-linux-gnu/libgroonga.so.0(+0xe68ad) [0x79d5ad2e68ad]この中の+0xe68adの部分がaddr2lineに渡すアドレスになります。これを渡すと「XXX.cの29行目だよ」のように教えてくれます。C言語がスクリプト言語よりデバッグが難しい原因の1つがバックトレースを取得しにくい（クラッシュした箇所を特定しにくい）ことですが、（glibcのバックトレース用関数と）addr2lineを使うことでそれを解消することができます。便利そうでしょ？デバッグ情報では、addr2lineはどうやってアドレスから該当するソースコードの位置を特定しているのでしょうか。あぁ、これも私は雰囲気でしかわかっていないですね。私がこんな感じで動いているんじゃないかな？と思っていることを説明しましょう。（違ったら教えて。）addr2lineはアドレスを元にソースコードの位置を特定していると説明しましたが、実は入力はアドレ
</div><div class="ui-feed-item__date" title="2024-12-24 15:00:00">1ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://www.clear-code.com/blog/2024/12/24/how-to-deploy-container-image-with-tagging.html"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://www.clear-code.com/blog/2024/12/24/how-to-deploy-container-image-with-tagging.html">Fluentdのコンテナイメージをタグを打つだけでデプロイできるようにした方法</a><div class="ui-feed-item__blog-title">ククログ</div><div class="ui-feed-item__summary">
先日、Fluentdのv1.18.0をリリースしました。v1.18.0の変更点についてはFluentd v1.18.0をリリースに関する記事を参照していただくとして、このリリースから、Docker Hubで提供しているコンテナイメージの提供方法を改善し、GitHubでリリース用のタグを打つことで、コンテナイメージをDocker Hubへとデプロイできるようにしました。本記事ではどのようにしてそのしくみを実現したのかについて概要を説明します。従来のコンテナイメージのデプロイ方法これまでは、FluentdはSponsored OSSでありDocker Free Teamとして扱われていました。この状態だと、Automated BuildsとよばれるコンテナイメージをWebインターフェースから簡単にビルドできる仕組みが利用可能でした。しかし、Sponsored OSSであり、Docker Free Teamに所属していても、いつからかAutomated BuildsのWebインタフェースが利用できなくなりました。したがって、これまでのようにWebインタフェースから簡単にコンテナイメージをビルド・デプロイすることができなくなりました。Dockerfileとイメージをデプロイするためのフックの設定（hub.docker.com側でWebインタフェースと連動して実行される）をメンテナンスしていましたが、その仕組みは使えなくなったのです。Automated BuildsのWebインタフェースが利用できることを前提としたフックとなっていたので、これらを置き換える必要がでてきました。そこで、Automated Buildsに依存しない新たなやり方を模索する必要がありました。GitHub Actionsへの移行のポイントFluentdのコンテナイメージとしては次の5つのタイプのイメージを提供していました。(Windowsのコンテナイメージだけは別途手動でメンテナンスしています。)alpine (非推奨。歴史的経緯でまだ提供している)amd64arm64armhfWindowsこのうち、Windowsのコンテナイメージを除いてGitHub Actionsでコンテナイメージをビルド、アップロードするようにしました。具体的な例はdocker-build.ymlです。基本的には次のようなことを
</div><div class="ui-feed-item__date" title="2024-12-23 15:00:00">1ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://www.clear-code.com/blog/2024/12/16/ruby-3.4.0-libraries.html"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://www.clear-code.com/blog/2024/12/16/ruby-3.4.0-libraries.html">Ruby 3.4.0のcsv/fiddle/rexml/stringio/strscan/test-unit</a><div class="ui-feed-item__blog-title">ククログ</div><div class="ui-feed-item__summary">
Rubyの開発に参加している須藤です。そろそろRuby 3.4.0がリリースされるので私がメンテナンスしているdefault gem/bundled gemの変更点を簡単に紹介します。対象gem紹介するgemは次の通りです。default gemがRubyに組み込まれているgemで、bundled gemがRubyをインストールするときに普通のgemとしてついでにインストールされるgemです。どちらも新しいバージョンを普通のgemとしてインストールすることで、Ruby本体のバージョンを上げなくても新しいバージョンのgemを使えるようになります。csv: bundled gemfiddle: default gemrexml: bundled gemstringio: default gemstrscan: default gemtest-unit: bundled gemcsvcsv gemはCSVを扱うgemです。csv gemの変更点はこんな感じです。GH-2963つの条件が重なったときにパースに失敗する「ことがある」問題を修正しました。（4つの条件とか言ったほうがいいかもしれないけど、もう1つの条件を説明するのが面倒。。。）GH-301CSV.openがデフォルトでBOMを自動検出するようになりました。ただし！Windowsでは自動検出しません。これはRuby本体のWindowsでのBOMの検出機能がなんか変だからです。気が向いたら直そうかと思っていましたが、普段Windowsを使っていないこともあり全然気が向かなかったのでなにもしていません。だれか直して。なお、CSVにBOMが入る原因のほぼすべてはExcelなはずです。Excelが出力するCSVにはBOMが入っているはずなんです。なので、Windowsでこそこの機能があった方が便利になるはずなのですが、前述の通り無効になっています。Excelで作られたCSVを違う環境で扱うときはこれで便利になるはずです。GH-300CSV.openがStringIOを受け付けるようになりました。普通は文字列かIOを渡すと思うので、StringIOを受け付ける必要性はあまりないと思うのですが、IOを受け付けるならStringIOも受け付けていいよねーということで受け付けるようになりました。GH-313いくつか組み込みで値を変
</div><div class="ui-feed-item__date" title="2024-12-15 15:00:00">1ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://www.clear-code.com/blog/2024/12/13/pg-regress-altenative-expect-file.html"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://www.clear-code.com/blog/2024/12/13/pg-regress-altenative-expect-file.html">pg_regressは期待値ファイルを複数指定できる</a><div class="ui-feed-item__blog-title">ククログ</div><div class="ui-feed-item__summary">
PostgreSQLにいくつかパッチを投げている須藤です。パッチのレビューの中で、PostgreSQLのリグレッションテストツールpg_regressに今まで知らなかった機能があったことを知ったので紹介します。pg_regress&quot;&gt;pg_regresspg_regressはいわゆるエンドツーエンドのテストツールです。PostgreSQLクライアントでサーバーに接続してSQLを実行し、そのときの実行結果があらかじめ用意してある期待値と同じになっているかどうかでテストします。MySQLでいえばmysqltest、Groongaでいえばgrntest相当のツールです。Webアプリケーションのテストではエンドツーエンドのテストは実行時間が長くなりがちでできるだけ書きたくないテストになりやすいですが、データベースのテストの場合はそうでもありません。たしかに、Cで書いた単体テストのほうが実行時間が短くなりやすいですが、CではなくSQLでテストを書けるので、エンドツーエンドのテストの方がメンテナンスしやすいです。また、実際にユーザーが使うときと同じ一連の処理を少ないテストでカバーできることもメンテナンスのしやすさにつながります。Groonga・Mroongaは、昔は単体テストも書いていましたが、今はエンドツーエンドのテストしか書いていません。ということで、PostgreSQLのテストを書くにあたりすごく便利なツールがpg_regressです。pg_regressが苦手なところ&quot;&gt;pg_regressが苦手なところ便利といってもなにもかもpg_regressでカバーできるわけではありません。pg_regressはSQLでテストを書くので、SQLで書かないようなことは苦手です。たとえば、SQLを発行する前の接続関連のテストは苦手ですし、レプリケーションのように複数の接続にまたがるようなケースや、PostgreSQL起動時に設定をしなければいけないようなケースも苦手です。環境によって結果が変わるようなケースも苦手だと私は思っていました。pg_regressはPostgreSQLクライアントとしてpsqlを使うので、SQLではできないけどpsqlでできることならできます。たとえば、条件分岐をできます。SQLでもplpgsqlを使えば条件分岐をできますが、psqlの方がもっとがんばれる気
</div><div class="ui-feed-item__date" title="2024-12-12 15:00:00">1ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://www.clear-code.com/blog/2024/12/13/how-to-add-support-for-new-data-type.html"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://www.clear-code.com/blog/2024/12/13/how-to-add-support-for-new-data-type.html">PGroongaの演算子に新しいデータ型のサポートを追加する方法</a><div class="ui-feed-item__blog-title">ククログ</div><div class="ui-feed-item__summary">
最近、PGroongaの演算子を改良した堀本です。今回、正規表現を用いた検索で使う演算子に新しいデータ型のサポートを追加したので、どうやって追加したかを紹介します。開発の背景今回改良したのは&amp;~演算子（正規表現検索用の演算子）です。今回の改良を行う前は、text型とvarvhar型のカラムに対してのみ正規表現を使った検索をサポートしていました。しかし、PostgreSQLには他にもtext[]型やvarchar[]型のように文字列を格納するデータ型があります。今回は、text[]型のカラムに対して正規表現を用いて後方一致検索を実現したいというケースがあったため、text[]型をサポートしました。開発の手順まず、text[] &amp;~ textの形でクエリーが実行された時に呼び出される関数を定義/実装しその後、&amp;~演算子にtext[]型のサポートを追加します。最後に、アップグレード/ダウングレード時に今回追加した定義を追加/削除するためのSQLを書いて完了です。まとめると、以下のような手順で演算子を改良します。新しい関数の定義新しい関数の実装既存の演算子にデータ型を追加アップグレード/ダウングレードSQLの作成新しい関数の定義最初にtext[] &amp;~ textの形でクエリーが実行された時に呼び出される関数を定義します。関数の実装はまた別途行うので、ここでは定義だけ行います。関数の定義は、CREATE FUNCTIONを使って行います。関数の定義を追加する場所は、 https://github.com/pgroonga/pgroonga/blob/main/data/pgroonga.sql です。関数の名前や引数、戻り値の型等を定義します。関数名は、pgroonga_regexp_text_arrayとし、引数はtext[] &amp;~ textの左辺と、右辺のデータを取ります。また、戻り値はtext[] &amp;~ textの条件にヒットするかどうかを返すのでboolになります。以上から、関数の定義は以下のようになります。CREATE FUNCTION pgroonga_regexp_text_array(targets text[], pattern text)RETURNS boolAS &#39;MODULE_PATHNAME&#39;, &#39;pgroonga_regexp_text_arra
</div><div class="ui-feed-item__date" title="2024-12-12 15:00:00">1ヶ月前</div></div></div></div></div></section></main><footer role="contentinfo" class="ui-section-footer"><div class="ui-layout-container"><div class="ui-layout-column-6 ui-layout-column-center"><div class="ui-component-cta ui-layout-flex ui-section-footer__site-info"><p class="ui-text-note">このサイトは<br>記事を読んでその企業の技術・カルチャーを知れることや<br>質の高い技術情報を得られることを目的としています。</p><p class="ui-text-note">追加したいブログがある場合は<br><a href="https://github.com/yamadashy/tech-blog-rss-feed#%E3%82%B5%E3%82%A4%E3%83%88%E3%81%AE%E8%BF%BD%E5%8A%A0%E6%96%B9%E6%B3%95" target="_blank">サイトの追加方法</a> をご参照ください。</p></div></div></div><div class="ui-layout-container"><div class="ui-section-footer__layout ui-layout-flex"><p class="ui-section-footer--copyright ui-text-note"><a class="ui-text-note" href="https://github.com/yamadashy/" target="_blank"><small>@yamadashy</small></a></p><a href="https://github.com/yamadashy/tech-blog-rss-feed/" role="link" aria-label="#" 
class="ui-text-note" target="_blank"><small>GitHub</small></a></div></div></footer></body></html>